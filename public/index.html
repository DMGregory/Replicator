<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      * {
        margin: 0;
      }
    </style>
    <!-- <link rel="stylesheet" type="text/css" href="styles.css"> -->
  </head>
  <body>
    <script src="connect.js"></script>
    <script type="module">
      'use strict';

      import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';
      import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js';
      import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.119.1/examples/jsm/webxr/XRControllerModelFactory.min.js';

      const clock = new THREE.Clock();
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;

      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      function vectorToString(v) {
        return `(${v.x}, ${v.y}, ${v.z})`;
      }

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.05,
        100
      );
      camera.position.y = 1.5;
      camera.position.z = 1.5;


      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.75, 0);

      function resize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      resize();
      window.addEventListener('resize', resize, false);

      // create the root of a scene graph
      const scene = new THREE.Scene();

      const fadeColor = 0x5099c5;
      scene.background = new THREE.Color(fadeColor);
      scene.fog = new THREE.FogExp2(fadeColor, 0.1);

      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshLambertMaterial();
      const cube = new THREE.Mesh(geometry, material);

      // position the cube, and add it to the scene:
      cube.position.y = 1.5;
      cube.position.z = -3.0;
      cube.castShadow = true;
      scene.add(cube);

      /*
      const secondCube = new THREE.Mesh(geometry, material);
      secondCube.position.y = 1.5;
      secondCube.position.z = -2.0;
      secondCube.position.x = 0;
      secondCube.scale.x = 0.5;
      secondCube.scale.y = 0.2;
      secondCube.scale.z = 0.3;
      secondCube.castShadow = true;
      scene.add(secondCube);
      */

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), material);
      floor.receiveShadow = true;
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      const grid = new THREE.GridHelper(35, 35, 0x333366, 0x666666);
      scene.add(grid);

      const light = new THREE.HemisphereLight(0xfffcee, 0x202555);
      scene.add(light);

      const directional = new THREE.DirectionalLight(0xfff2dd, 1.0);
      directional.position.set(-1, 7, 0.5);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      directional.castShadow = true;
      scene.add(directional);

      const ico = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.1),
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
      );
      ico.position.z = -1;
      scene.add(ico);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Controller handling from WebXR BallShooter example:
      // https://github.com/mrdoob/three.js/blob/master/examples/webxr_vr_ballshooter.html
      let controller1, controller2, controllerGrip1, controllerGrip2;
      init();
      function init() {
        // controllers
        function onSelectStart() {
          this.userData.isSelecting = true;
        }

        function onSelectEnd() {
          this.userData.isSelecting = false;
        }

        controller1 = renderer.xr.getController( 0 );
        controller1.addEventListener( 'selectstart', onSelectStart );
        controller1.addEventListener( 'selectend', onSelectEnd );
        controller1.addEventListener( 'connected', function ( event ) {
          this.add( buildController( event.data ) );
        } );
        controller1.addEventListener( 'disconnected', function () {
          this.remove( this.children[ 0 ] );
        } );
        scene.add( controller1 );

        controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', onSelectStart );
        controller2.addEventListener( 'selectend', onSelectEnd );
        controller2.addEventListener( 'connected', function ( event ) {
          this.add( buildController( event.data ) );
        } );
        controller2.addEventListener( 'disconnected', function () {
          this.remove( this.children[ 0 ] );
        } );
        scene.add( controller2 );

        // The XRControllerModelFactory will automatically fetch controller models
        // that match what the user is holding as closely as possible. The models
        // should be attached to the object returned from getControllerGrip in
        // order to match the orientation of the held device.
        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip( 0 );
        controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
        scene.add( controllerGrip1 );

        controllerGrip2 = renderer.xr.getControllerGrip( 1 );
        controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
        scene.add( controllerGrip2 );
      }
      function buildController( data ) {
        let geometry, material;

        switch ( data.targetRayMode ) {
          case 'tracked-pointer':
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
            geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );
            material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );
            return new THREE.Line( geometry, material );

          case 'gaze':
            geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
            material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
            return new THREE.Mesh( geometry, material );
        }

      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      renderer.domElement.onmousemove = onMouseMove;

      let gazeObject = null;





      const readout = document.createElement('div');
      readout.style.position = 'absolute';
      readout.style.top = '0px';
      document.body.appendChild(readout);


      let toPrint = "";
      function print(text) {
        toPrint += text + "<br/>";
      } 

      const app = connectToWorld();

      const replicas = {};


      function animate() {
        const dt = clock.getDelta();
        const t = clock.getElapsedTime();

        if (renderer.xr && renderer.xr.isPresenting) {
          mouse.set(0, 0);
          //print(renderer.xr.getCamera());
        } else {
          controls.update(dt);      
        }

        /*
        secondCube.position.copy(camera.position);
        secondCube.position.z -= 1.5;
        camera.getWorldQuaternion(secondCube.quaternion);
        */

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([
          cube,
          floor,
        ]);

        let newGaze = null;
        if (intersects.length > 0) {
          ico.position.copy(intersects[0].point);
          newGaze = intersects[0].object;
        }


        // update the scene:
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;

        ico.rotation.x -= 0.01;
        ico.rotation.y -= 0.01;

        
        // TODO: Offset by player position/rig,
        // so users aren't all overlapped in one spot.

        let {self, others} = app.world;
        self.pos[0] = camera.position.x;
        self.pos[1] = camera.position.y;
        self.pos[2] = camera.position.z;

        self.quat[0] = camera.quaternion.x;
        self.quat[1] = camera.quaternion.y;
        self.quat[2] = camera.quaternion.z;
        self.quat[3] = camera.quaternion.w;

        let i = 0;
        others.forEach(o => {
          i++;
          let r = replicas[o.id];

          if (r === undefined) {
            console.log(`creating replica for user ${o.id}`);
            let head = new THREE.Mesh(geometry, material);
            head.scale.x = 0.5;
            head.scale.y = 0.2;
            head.scale.z = 0.3;
            head.castShadow = true;
            scene.add(head);
            r = {head: head};
            replicas[o.id] = r;
          }
          
          r.head.position.set(o.pos[0], o.pos[1], o.pos[2]+2);
          r.head.quaternion.set(o.quat[0], o.quat[1], o.quat[2], o.quat[3]);
        });        

        print(`others: ${i}`);

        // draw the scene:
        renderer.render(scene, camera);

        readout.innerHTML = toPrint;
        toPrint = "";
      }
      // start!
      renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
