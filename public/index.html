<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      * {
        margin: 0;
      }
    </style>
    <!-- <link rel="stylesheet" type="text/css" href="styles.css"> -->
  </head>
  <body>
    <script src="utility.js"></script>
    <script src="connect.js"></script>
    <script type="module">
      'use strict';

      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.126.0/build/three.module.js';      
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.126.0/examples/jsm/controls/OrbitControls.js';      
      import { initializeWorld } from "/world.js"; 
      import { setupLocalUser } from "/replication.js"; 

      // Prep a DOM element to display debug messages.
      const readout = document.createElement('div');
      readout.style.position = 'absolute';
      readout.style.top = '0px';
      document.body.appendChild(readout);

      const world = initializeWorld();      


      
      const cube = new THREE.Mesh(world.primitiveGeo.box, world.defaultMaterial);

      // position the cube, and add it to the scene:
      cube.position.y = 1.5;
      cube.position.z = 0;
      cube.castShadow = true;
      world.scene.add(cube);


      const ico = new THREE.Mesh(world.primitiveGeo.ico,
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
      );
      ico.scale.set(0.1, 0.1, 0.1);
      ico.position.z = -1;
      world.scene.add(ico);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();



      let angle = Math.random() * Math.PI * 2;
      setupLocalUser(Math.sin(angle) * 3, Math.cos(angle) * 3, angle, world);
      

      const controls = new OrbitControls(world.camera, world.renderer.domElement);
      controls.target.set(0, 0.75, 0);

      

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      world.renderer.domElement.onmousemove = onMouseMove;

      let gazeObject = null;



      const app = connectToWorld({
        url: window.location.href.startsWith('http://localhost') ? 
        'ws://127.0.0.1:3000' :
        'wss://digm5520replicator.herokuapp.com',
      });

      const replicas = {};

      function animate() {
        const dt = world.clock.getDelta();
        const t = world.clock.getElapsedTime();

        if (world.renderer.xr && world.renderer.xr.isPresenting) {
          mouse.set(0, 0);
        } else {
          controls.update(dt);
        }

        raycaster.setFromCamera(mouse, world.camera);
        const intersects = raycaster.intersectObjects([cube, world.floor]);

        let newGaze = null;
        if (intersects.length > 0) {
          ico.position.copy(intersects[0].point);
          newGaze = intersects[0].object;
        }

        // update the scene:
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;

        ico.rotation.x -= 0.01;
        ico.rotation.y -= 0.01;

        let { self, others } = app.world;
        let p = new THREE.Vector3();
        world.camera.getWorldPosition(p);
        self.pos[0] = p.x;
        self.pos[1] = p.y;
        self.pos[2] = p.z;

        let q = new THREE.Quaternion();
        world.camera.getWorldQuaternion(q);
        self.quat[0] = q.x;
        self.quat[1] = q.y;
        self.quat[2] = q.z;
        self.quat[3] = q.w;

        let otherCount = 0;
        others.forEach((o) => {
          otherCount++;
          let r = replicas[o.id];

          if (r === undefined) {
            console.log(`creating replica for user ${o.id}`);
            let head = new THREE.Mesh(world.primitiveGeo.box, material);
            head.scale.x = 0.5;
            head.scale.y = 0.2;
            head.scale.z = 0.3;
            head.castShadow = true;
            world.scene.add(head);
            r = { head: head };
            replicas[o.id] = r;
          }

          r.head.position.set(o.pos[0], o.pos[1], o.pos[2]);
          r.head.quaternion.set(o.quat[0], o.quat[1], o.quat[2], o.quat[3]);
          r.lastUpdate = t;
        });

        for (let key in replicas) {
          let r = replicas[key];
          if (r.lastUpdate < t) {
            console.log(`Removing replica for ${key}`, r);
            world.scene.remove(r.head);
            delete replicas[key];
          }
        }

        // draw the scene:
        world.renderer.render(world.scene, world.camera);

        showReadout(readout);
      }
      // start!
      world.renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
